<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Tetris Battle</title>
    <style>
        :root {
            --neon-blue: #00f3ff;
            --dark-bg: #0b0c10;
            --panel-bg: rgba(31, 40, 51, 0.85);
            --border-color: rgba(69, 162, 158, 0.5);
        }
        body {
            background: radial-gradient(circle at center, #1a222a 0%, var(--dark-bg) 100%);
            color: #c5c6c7;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        /* --- 開始與倒數介面 --- */
        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(11, 12, 16, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            transition: opacity 0.5s ease;
        }

        /* --- 暫停介面 --- */
        #pause-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(11, 12, 16, 0.85);
            display: none; 
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 900;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .mode-selection {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        .mode-title {
            font-size: 32px;
            font-weight: 900;
            color: var(--neon-blue);
            margin-bottom: 20px;
            letter-spacing: 4px;
            text-shadow: 0 0 15px rgba(0, 243, 255, 0.5);
        }
        .start-btn {
            padding: 15px 40px;
            font-size: 20px;
            letter-spacing: 2px;
            background: transparent;
            color: var(--neon-blue);
            border: 2px solid var(--neon-blue);
            border-radius: 50px;
            cursor: pointer;
            font-weight: 900;
            transition: all 0.3s;
            min-width: 250px;
        }
        .start-btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.6);
            transform: translateY(-3px);
        }
        #countdown-display {
            position: absolute;
            font-size: 150px;
            font-weight: 900;
            color: var(--neon-blue);
            text-shadow: 0 0 40px var(--neon-blue);
            display: none;
            pointer-events: none;
            z-index: 1001;
        }
        .countdown-anim {
            animation: count-zoom 1s ease-out forwards;
        }
        @keyframes count-zoom {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1.8); opacity: 0; }
        }

        #game-wrapper {
            position: relative; 
            display: flex;
            gap: 25px;
            background: var(--panel-bg);
            padding: 30px 40px;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.1), inset 0 0 20px rgba(255,255,255,0.05);
            backdrop-filter: blur(15px);
        }
        .board-container { position: relative; }
        canvas#tetris {
            background-color: #050505;
            border: 2px solid #45a29e;
            border-radius: 5px;
            box-shadow: 0 0 25px rgba(69, 162, 158, 0.25);
            display: block;
        }
        .panel {
            display: flex;
            flex-direction: column;
            width: 160px;
        }
        .info-box {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(69, 162, 158, 0.3);
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            font-size: 14px;
            letter-spacing: 1px;
            color: #aaa;
        }
        .info-box span {
            display: block;
            font-size: 28px;
            font-weight: 900;
            color: var(--neon-blue);
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
            margin-top: 5px;
            font-family: 'Courier New', Courier, monospace;
        }
        .preview-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas.mini-canvas {
            margin-top: 5px;
            border: none;
            background: transparent;
        }
        .exit-btn {
            background: rgba(255, 51, 51, 0.1);
            border: 1px solid #ff3333;
            color: #ff3333;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 10px;
            transition: all 0.2s;
        }
        .exit-btn:hover {
            background: #ff3333;
            color: #000;
        }

        .controls-hint { 
            font-size: 12px; color: #888; margin-top: auto; line-height: 1.8; 
            background: rgba(0,0,0,0.2); padding: 15px; border-radius: 10px;
            border: 1px dashed rgba(69, 162, 158, 0.3);
        }
        .controls-hint b { color: #c5c6c7; font-size: 13px;}
        
        #gameOverScreen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(11, 12, 16, 0.95); flex-direction: column;
            justify-content: center; align-items: center; border-radius: 20px;
            z-index: 200; backdrop-filter: blur(8px);
        }
        #gameOverScreen h1 {
            color: #ff4444; font-size: 48px; margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 68, 68, 0.6);
        }
        #messageDisplay {
            position: absolute; top: 35%; left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            color: #ffcc00; font-size: 36px; font-weight: 900; font-style: italic;
            text-shadow: 0 4px 0 #b38f00, 0 0 20px rgba(255, 204, 0, 0.8);
            white-space: nowrap; opacity: 0; pointer-events: none; z-index: 100;
            transition: opacity 0.2s, transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .msg-show { opacity: 1 !important; transform: translate(-50%, -50%) scale(1) !important; }
        
        .msg-tspin {
            color: #fff !important;
            text-shadow: 0 4px 0 #990099, 0 0 20px #cc33cc, 0 0 40px #00ffff !important;
            animation: tspinPop 0.6s ease-out forwards;
        }
        @keyframes tspinPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            40% { transform: translate(-50%, -50%) scale(1.3) rotate(-5deg); opacity: 1; }
            60% { transform: translate(-50%, -50%) scale(1.3) rotate(5deg); opacity: 1; }
            80% { transform: translate(-50%, -50%) scale(1.3) rotate(-5deg); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
        }
        .msg-allclear {
            color: #fff !important;
            text-shadow: 0 0 10px #fff, 0 0 20px var(--neon-blue), 0 0 40px var(--neon-blue) !important;
            font-size: 48px !important;
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="start-overlay">
        <div class="mode-selection" id="modeButtons">
            <div class="mode-title">SELECT MODE</div>
            <button class="start-btn" onclick="initiateCountdown('TIME')">2 分鐘計分模式</button>
            <button class="start-btn" onclick="initiateCountdown('LINES')">40 行競速模式</button>
        </div>
        <div id="countdown-display">3</div>
    </div>

    <div id="pause-overlay">
        <div class="mode-selection">
            <div class="mode-title">PAUSED</div>
            <button class="start-btn" onclick="resumeGame()">繼續冒險</button>
            <button class="start-btn" style="border-color: #ff3333; color: #ff3333;" onclick="showStartOverlay()">退出冒險</button>
        </div>
    </div>

    <div id="gameOverScreen">
        <h1 id="gameOverTitle">挑戰失敗！</h1>
        <p id="gameOverSub" style="margin-bottom: 30px; font-size: 18px;">方塊已經觸頂了，請重新選擇模式</p>
        <div style="display: flex; gap: 15px;">
            <button class="start-btn" style="min-width: 200px; font-size: 16px;" onclick="showStartOverlay()">回到主選單</button>
        </div>
    </div>

    <div class="panel">
        <div class="info-box preview-box">
            HOLD (鍵盤 0)
            <canvas id="holdCanvas" class="mini-canvas" width="120" height="120"></canvas>
        </div>
        <div class="info-box">TIME<span id="timeDisplay">0:00</span></div>
        <div class="info-box">SCORE<span id="scoreDisplay">0</span></div>
        <div class="info-box">LINES<span id="linesDisplay">0</span></div>
        
        <button class="exit-btn" id="pauseBtn" onclick="togglePause()">暫停 / 退出冒險</button>
        
        <div class="controls-hint">
            <b>操作說明：</b><br>
            ← → : 左右移動<br>
            ↑ : 順時針旋轉<br>
            Z : 逆時針旋轉<br>
            數字 0 : 儲存 (Hold)<br>
            ↓ (按住) : 加速下落<br>
            空白 : 瞬間下落<br>
        </div>
    </div>
    
    <div class="board-container">
        <canvas id="tetris" width="350" height="700"></canvas>
        <div id="messageDisplay"></div>
    </div>
    
    <div class="panel">
        <div class="info-box preview-box" style="flex-grow: 1;">
            NEXT
            <canvas id="nextCanvas" class="mini-canvas" width="120" height="420"></canvas>
        </div>
        <div class="controls-hint">
            <b>Made by</b><br>
            Michael<br>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');
    const BLOCK_SIZE = 35; 
    context.scale(BLOCK_SIZE, BLOCK_SIZE);

    const holdCanvas = document.getElementById('holdCanvas');
    const holdCtx = holdCanvas.getContext('2d');
    const MINI_SCALE = 24; 
    holdCtx.scale(MINI_SCALE, MINI_SCALE);

    const nextCanvas = document.getElementById('nextCanvas');
    const nextCtx = nextCanvas.getContext('2d');
    nextCtx.scale(MINI_SCALE, MINI_SCALE);

    const DAS = 130; 
    const ARR = 25;  
    const keysState = { left: false, right: false };
    let leftTimer = 0, rightTimer = 0;
    
    const NORMAL_DROP_SPEED = 1000;
    const FAST_DROP_SPEED = 30; 
    const LOCK_DELAY = 500; 
    let lockTimer = 0, dropCounter = 0, dropInterval = NORMAL_DROP_SPEED;

    let lastTime = 0, animationId = null, gameMode = null; 
    let timer = 0, timerInterval = null;
    let isGameOver = true; 
    let isPaused = false; 
    let lastActionWasRotation = false;

    let isAnimating = false, clearAnimTimer = 0;
    const CLEAR_ANIM_DURATION = 200; // 漸隱動畫時長
    let clearLinesList = [], tSpinClear = false;

    let nextQueue = [], heldPieceType = null, canHold = true;
    let arena = createMatrix(10, 20);

    const player = { 
        pos: {x: 0, y: 0}, 
        matrix: null, 
        pieceType: null, 
        score: 0, 
        lines: 0,
        rotation: 0 
    };

    const pieces = 'ILJOTSZ';
    const colors = [ null, '#00ffff', '#3366ff', '#ff9900', '#ffcc00', '#33cc33', '#cc33cc', '#ff3333' ];

    const kickData = {
        'default': {
            '0-1': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]], '1-0': [[0,0], [1,0], [1,-1], [0,2], [1,2]],
            '1-2': [[0,0], [1,0], [1,-1], [0,2], [1,2]], '2-1': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
            '2-3': [[0,0], [1,0], [1,1], [0,-2], [1,-2]], '3-2': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
            '3-0': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]], '0-3': [[0,0], [1,0], [1,1], [0,-2], [1,-2]]
        },
        'I': {
            '0-1': [[0,0], [-2,0], [1,0], [-2,-1], [1,2]], '1-0': [[0,0], [2,0], [-1,0], [2,1], [-1,-2]],
            '1-2': [[0,0], [-1,0], [2,0], [-1,2], [2,-1]], '2-1': [[0,0], [1,0], [-2,0], [1,-2], [-2,1]],
            '2-3': [[0,0], [2,0], [-1,0], [2,1], [-1,-2]], '3-2': [[0,0], [-2,0], [1,0], [-2,-1], [1,2]],
            '3-0': [[0,0], [1,0], [-2,0], [1,-2], [-2,1]], '0-3': [[0,0], [-1,0], [2,0], [-1,2], [2,-1]]
        }
    };

    function togglePause() {
        if (isGameOver || isAnimating) return;
        isPaused = true;
        isGameOver = true; 
        clearInterval(timerInterval);
        document.getElementById('pause-overlay').style.display = 'flex';
    }

    function resumeGame() {
        document.getElementById('pause-overlay').style.display = 'none';
        initiateCountdown(null, true);
    }

    function showStartOverlay() {
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('pause-overlay').style.display = 'none';
        document.getElementById('start-overlay').style.display = 'flex';
        document.getElementById('start-overlay').style.opacity = '1';
        document.getElementById('modeButtons').style.display = 'flex';
        document.getElementById('countdown-display').style.display = 'none';
        isGameOver = true;
        isPaused = false;
        if (timerInterval) clearInterval(timerInterval);
        cancelAnimationFrame(animationId);
    }

    function initiateCountdown(mode, isResuming = false) {
        if (!isResuming) {
            gameMode = mode;
            document.getElementById('modeButtons').style.display = 'none';
        }
        
        const countdownEl = document.getElementById('countdown-display');
        countdownEl.style.display = 'block';
        document.getElementById('start-overlay').style.display = 'flex';
        document.getElementById('start-overlay').style.opacity = '1';

        let count = 3;
        countdownEl.innerText = count;
        countdownEl.classList.remove('countdown-anim');
        void countdownEl.offsetWidth;
        countdownEl.classList.add('countdown-anim');

        const cdTimer = setInterval(() => {
            count--;
            if (count > 0) {
                countdownEl.innerText = count;
                countdownEl.classList.remove('countdown-anim');
                void countdownEl.offsetWidth;
                countdownEl.classList.add('countdown-anim');
            } else {
                clearInterval(cdTimer);
                countdownEl.style.display = 'none';
                document.getElementById('start-overlay').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('start-overlay').style.display = 'none';
                    if (isResuming) {
                        isPaused = false;
                        isGameOver = false;
                        lastTime = performance.now();
                        timerInterval = setInterval(updateTimer, 1000);
                        update();
                    } else {
                        startGame(gameMode);
                    }
                }, 500);
            }
        }, 1000);
    }

    function createMatrix(w, h) {
        return Array.from({length: h}, () => new Array(w).fill(0));
    }

    function createPiece(type) {
        if (type === 'I') return [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]];
        if (type === 'J') return [[2,0,0], [2,2,2], [0,0,0]];
        if (type === 'L') return [[0,0,3], [3,3,3], [0,0,0]];
        if (type === 'O') return [[4,4], [4,4]];
        if (type === 'S') return [[0,5,5], [5,5,0], [0,0,0]];
        if (type === 'T') return [[0,6,0], [6,6,6], [0,0,0]];
        if (type === 'Z') return [[7,7,0], [0,7,7], [0,0,0]];
    }

    function playerRotate(dir) {
        if (isAnimating || isPaused) return;
        const startRot = player.rotation;
        const targetRot = (player.rotation + dir + 4) % 4;
        const matrix = JSON.parse(JSON.stringify(player.matrix));
        rotateMatrix(matrix, dir);
        const typeKey = (player.pieceType === 'I') ? 'I' : 'default';
        const tests = kickData[typeKey][`${startRot}-${targetRot}`];
        for (let i = 0; i < tests.length; i++) {
            const [x, y] = tests[i];
            const testPos = { x: player.pos.x + x, y: player.pos.y - y };
            if (!collide(arena, { matrix, pos: testPos })) {
                player.matrix = matrix; player.pos = testPos; player.rotation = targetRot;
                lastActionWasRotation = true; lockTimer = 0; return;
            }
        }
    }

    function rotateMatrix(matrix, dir) {
        for (let y = 0; y < matrix.length; ++y) {
            for (let x = 0; x < y; ++x) { [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; }
        }
        if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse();
    }

    function checkAllClear() {
        return arena.every(row => row.every(value => value === 0));
    }

    function executeClearLines() {
        let rowCount = clearLinesList.length;
        let newArena = arena.filter((row, y) => !clearLinesList.includes(y));
        while (newArena.length < 20) newArena.unshift(new Array(10).fill(0));
        arena = newArena;
        player.lines += rowCount;
        let msg = "";
        if (tSpinClear) {
            if (rowCount === 1) { player.score += 800; msg = "T-SPIN SINGLE"; }
            else if (rowCount === 2) { player.score += 1200; msg = "T-SPIN DOUBLE"; }
            else if (rowCount === 3) { player.score += 1600; msg = "T-SPIN TRIPLE"; }
        } else {
            const rowScores = [0, 100, 300, 500, 800];
            player.score += rowScores[rowCount] || 0;
            if (rowCount === 4) msg = "TETRIS!";
            else if (rowCount === 2) msg = "DOUBLE";
            else if (rowCount === 3) msg = "TRIPLE";
        }
        if (checkAllClear()) { player.score += 3000; showMessage("ALL CLEAR!", false, true); } 
        else if (msg !== "") { showMessage(msg, tSpinClear); }
        updateDisplay();
        if (gameMode === 'LINES' && player.lines >= 40) { endGame("挑戰成功！", `耗時: ${document.getElementById('timeDisplay').innerText}`); return; }
        isAnimating = false; playerReset();
    }

    function showMessage(text, isTspin = false, isAllClear = false) {
        const msgDiv = document.getElementById('messageDisplay');
        msgDiv.innerText = text; msgDiv.className = "msg-show";
        if (isTspin) msgDiv.classList.add("msg-tspin");
        if (isAllClear) msgDiv.classList.add("msg-allclear");
        setTimeout(() => msgDiv.className = "", 1200);
    }

    function fillQueue() {
        while (nextQueue.length <= 4) {
            let b = pieces.split('');
            for (let i = b.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [b[i], b[j]] = [b[j], b[i]];
            }
            nextQueue.push(...b);
        }
    }

    function drawBlock(ctx, x, y, value, isGhost = false) {
        if (value === 0) return;
        ctx.fillStyle = colors[value];
        if (isGhost) {
            ctx.globalAlpha = 0.25; ctx.fillRect(x, y, 1, 1); ctx.globalAlpha = 1;
            ctx.strokeStyle = colors[value]; ctx.lineWidth = 0.05; ctx.strokeRect(x + 0.05, y + 0.05, 0.9, 0.9);
        } else {
            ctx.fillRect(x, y, 1, 1);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + 1, y); ctx.lineTo(x + 0.8, y + 0.2); ctx.lineTo(x + 0.2, y + 0.2); ctx.fill();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath(); ctx.moveTo(x + 1, y); ctx.lineTo(x + 1, y + 1); ctx.lineTo(x + 0.8, y + 0.8); ctx.lineTo(x + 0.8, y + 0.2); ctx.fill();
            ctx.strokeStyle = '#000'; ctx.lineWidth = 0.05; ctx.strokeRect(x, y, 1, 1);
        }
    }

    function draw() {
        context.fillStyle = '#050505';
        context.fillRect(0, 0, canvas.width, canvas.height);
        drawGrid(context, 10, 20);
        
        // --- 修改消行動畫：漸隱 (Fade Out) ---
        arena.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    if (isAnimating && clearLinesList.includes(y)) {
                        context.globalAlpha = clearAnimTimer / CLEAR_ANIM_DURATION;
                    } else {
                        context.globalAlpha = 1;
                    }
                    drawBlock(context, x, y, value);
                    context.globalAlpha = 1;
                }
            });
        });

        if (!isAnimating && player.matrix) {
            const ghost = { matrix: player.matrix, pos: { x: player.pos.x, y: player.pos.y } };
            while (!collide(arena, ghost)) { ghost.pos.y++; }
            ghost.pos.y--;
            drawMatrix(context, ghost.matrix, ghost.pos, true);
            drawMatrix(context, player.matrix, player.pos);
        }
    }

    function drawGrid(ctx, width, height) {
        ctx.strokeStyle = '#222'; ctx.lineWidth = 0.02;
        for (let i = 0; i <= width; i++) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, height); ctx.stroke(); }
        for (let i = 0; i <= height; i++) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(width, i); ctx.stroke(); }
    }

    function drawMatrix(ctx, matrix, offset, isGhost = false) {
        matrix.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) drawBlock(ctx, x + offset.x, y + offset.y, value, isGhost); }); });
    }

    function collide(arena, player) {
        const [m, o] = [player.matrix, player.pos];
        for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < m[y].length; ++x) {
                if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
            }
        }
        return false;
    }

    function playerReset() {
        fillQueue();
        player.pieceType = nextQueue.shift();
        player.matrix = createPiece(player.pieceType);
        player.pos.y = 0;
        player.pos.x = Math.floor(arena[0].length / 2) - Math.floor(player.matrix[0].length / 2);
        player.rotation = 0;
        lastActionWasRotation = false;
        canHold = true; lockTimer = 0; dropCounter = 0;
        drawNext(); drawHold();
        if (collide(arena, player)) endGame("挑戰失敗！", "加油好嗎");
    }

    function isTSpin() {
        if (!lastActionWasRotation || player.pieceType !== 'T') return false;
        let corners = 0; const {x, y} = player.pos;
        const cornerCoords = [[0,0],[2,0],[0,2],[2,2]];
        cornerCoords.forEach(c => {
            if (arena[y + c[1]] === undefined || arena[y + c[1]][x + c[0]] !== 0) corners++;
        });
        return corners >= 3;
    }

    function checkAndStartClearAnimation() {
        clearLinesList = []; tSpinClear = isTSpin();
        for (let y = arena.length - 1; y >= 0; --y) { if (arena[y].every(v => v !== 0)) clearLinesList.push(y); }
        if (clearLinesList.length > 0) { 
            isAnimating = true; clearAnimTimer = CLEAR_ANIM_DURATION; return true; 
        }
        if (tSpinClear) showMessage("T-SPIN!", true);
        return false;
    }

    function playerMove(dir) {
        if (isAnimating || isPaused) return;
        player.pos.x += dir;
        if (collide(arena, player)) player.pos.x -= dir;
        else { lastActionWasRotation = false; lockTimer = 0; }
    }

    function holdPiece() {
        if (!canHold || isAnimating || isPaused) return;
        if (heldPieceType === null) {
            heldPieceType = player.pieceType; playerReset();
        } else {
            const temp = player.pieceType;
            player.pieceType = heldPieceType;
            player.matrix = createPiece(heldPieceType);
            heldPieceType = temp;
            player.pos.y = 0;
            player.pos.x = Math.floor(arena[0].length / 2) - Math.floor(player.matrix[0].length / 2);
            player.rotation = 0;
        }
        canHold = false; drawHold();
    }

    function merge(arena, player) {
        player.matrix.forEach((row, y) => {
            row.forEach((value, x) => { if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value; });
        });
    }

    function playerHardDrop() {
        if (isAnimating || isPaused) return;
        while (!collide(arena, player)) { player.pos.y++; }
        player.pos.y--; merge(arena, player);
        if (!checkAndStartClearAnimation()) playerReset();
        dropCounter = 0; lockTimer = 0; keysState.left = false; keysState.right = false;
    }

    function update(time = 0) {
        if (isGameOver || isPaused) return;
        const deltaTime = time - lastTime; lastTime = time;
        if (isAnimating) {
            clearAnimTimer -= deltaTime; draw();
            if (clearAnimTimer <= 0) executeClearLines();
            animationId = requestAnimationFrame(update); return;
        }
        if (keysState.left) { leftTimer += deltaTime; if (leftTimer >= DAS) { playerMove(-1); leftTimer -= ARR; } }
        if (keysState.right) { rightTimer += deltaTime; if (rightTimer >= DAS) { playerMove(1); rightTimer -= ARR; } }
        
        player.pos.y++;
        if (collide(arena, player)) {
            player.pos.y--; lockTimer += deltaTime;
            if (lockTimer >= LOCK_DELAY) {
                merge(arena, player);
                if (!checkAndStartClearAnimation()) playerReset();
            }
        } else {
            lockTimer = 0; dropCounter += deltaTime;
            if (dropCounter > dropInterval) { player.pos.y++; dropCounter = 0; }
            player.pos.y--;
        }
        draw(); animationId = requestAnimationFrame(update);
    }

    function updateDisplay() {
        document.getElementById('scoreDisplay').innerText = player.score;
        document.getElementById('linesDisplay').innerText = player.lines;
    }

    function updateTimer() {
        if (isGameOver || isPaused) return;
        gameMode === 'TIME' ? timer-- : timer++;
        if (timer <= 0 && gameMode === 'TIME') endGame("時間到！", `得分: ${player.score}`);
        const m = Math.floor(Math.abs(timer) / 60), s = Math.abs(timer) % 60;
        document.getElementById('timeDisplay').innerText = `${m}:${s.toString().padStart(2,'0')}`;
    }

    function startGame(mode) {
        gameMode = mode; arena = createMatrix(10, 20); player.score = 0; player.lines = 0;
        isGameOver = false; isPaused = false; isAnimating = false; nextQueue = []; heldPieceType = null;
        playerReset(); updateDisplay();
        timer = (mode === 'TIME') ? 120 : 0;
        clearInterval(timerInterval); timerInterval = setInterval(updateTimer, 1000);
        lastTime = performance.now(); update();
    }

    function endGame(t, s) {
        isGameOver = true; isPaused = false; clearInterval(timerInterval);
        document.getElementById('gameOverTitle').innerText = t;
        document.getElementById('gameOverSub').innerText = s;
        document.getElementById('gameOverScreen').style.display = 'flex';
    }

    function drawHold() {
        holdCtx.clearRect(0,0,120,120);
        if (heldPieceType) drawMatrix(holdCtx, createPiece(heldPieceType), {x:1, y:1});
    }

    function drawNext() {
        nextCtx.clearRect(0,0,120,420);
        nextQueue.slice(0,4).forEach((t, i) => drawMatrix(nextCtx, createPiece(t), {x:1, y:i*4+1}));
    }

    document.addEventListener('keydown', e => {
        if (isGameOver || isAnimating || isPaused) return;
        if (e.code === 'ArrowLeft') { keysState.left = true; playerMove(-1); leftTimer = 0; }
        if (e.code === 'ArrowRight') { keysState.right = true; playerMove(1); rightTimer = 0; }
        if (e.code === 'ArrowUp') playerRotate(1);
        if (e.key.toLowerCase() === 'z') playerRotate(-1);
        if (e.code === 'ArrowDown') dropInterval = FAST_DROP_SPEED;
        
        // --- 修改：快捷鍵由 Shift 改為 數字鍵 0 ---
        if (e.key === '0' || e.code === 'Digit0' || e.code === 'Numpad0') holdPiece();
        
        if (e.code === 'Space') playerHardDrop();
        if (["Space", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.code)) e.preventDefault();
    });

    document.addEventListener('keyup', e => {
        if (e.code === 'ArrowLeft') keysState.left = false;
        if (e.code === 'ArrowRight') keysState.right = false;
        if (e.code === 'ArrowDown') dropInterval = NORMAL_DROP_SPEED;
    });

    showStartOverlay();
</script>
</body>
</html>