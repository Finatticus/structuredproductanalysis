<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Tetris Battle Clone - Final Polish</title>
    <style>
        :root {
            --neon-blue: #00f3ff;
            --dark-bg: #0b0c10;
            --panel-bg: rgba(31, 40, 51, 0.85);
        }
        body {
            background: radial-gradient(circle at center, #1a222a 0%, var(--dark-bg) 100%);
            color: #c5c6c7;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #game-wrapper {
            position: relative; 
            display: flex;
            gap: 25px;
            background: var(--panel-bg);
            padding: 30px 40px;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.1), inset 0 0 20px rgba(255,255,255,0.05);
            backdrop-filter: blur(15px);
        }
        .board-container { position: relative; }
        canvas#tetris {
            background-color: #050505;
            border: 2px solid #45a29e;
            border-radius: 5px;
            box-shadow: 0 0 25px rgba(69, 162, 158, 0.25);
            display: block;
        }
        .panel {
            display: flex;
            flex-direction: column;
            width: 160px;
        }
        .info-box {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(69, 162, 158, 0.3);
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            font-size: 14px;
            letter-spacing: 1px;
            color: #aaa;
        }
        .info-box span {
            display: block;
            font-size: 28px;
            font-weight: 900;
            color: var(--neon-blue);
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
            margin-top: 5px;
            font-family: 'Courier New', Courier, monospace;
        }
        .preview-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas.mini-canvas {
            margin-top: 5px;
            border: none;
            background: transparent;
        }
        .btn-group { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
        button {
            padding: 10px;
            background: linear-gradient(45deg, #45a29e, #66fcf1);
            color: #0b0c10;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 900;
            font-size: 14px;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(102, 252, 241, 0.2);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 252, 241, 0.5);
        }
        .controls-hint { 
            font-size: 12px; color: #888; margin-top: auto; line-height: 1.8; 
            background: rgba(0,0,0,0.2); padding: 15px; border-radius: 10px;
            border: 1px dashed rgba(69, 162, 158, 0.3);
        }
        .controls-hint b { color: #c5c6c7; font-size: 13px;}
        #gameOverScreen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(11, 12, 16, 0.95); flex-direction: column;
            justify-content: center; align-items: center; border-radius: 20px;
            z-index: 200; backdrop-filter: blur(8px);
        }
        #gameOverScreen h1 {
            color: #ff4444; font-size: 48px; margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 68, 68, 0.6);
        }
        #messageDisplay {
            position: absolute; top: 35%; left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            color: #ffcc00; font-size: 36px; font-weight: 900; font-style: italic;
            text-shadow: 0 4px 0 #b38f00, 0 0 20px rgba(255, 204, 0, 0.8);
            white-space: nowrap; opacity: 0; pointer-events: none; z-index: 100;
            transition: opacity 0.2s, transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .msg-show { opacity: 1 !important; transform: translate(-50%, -50%) scale(1) !important; }
        .msg-tspin {
            color: #fff !important;
            text-shadow: 0 4px 0 #990099, 0 0 20px #cc33cc, 0 0 40px #00ffff !important;
            animation: tspinPop 0.6s ease-out forwards;
        }
        @keyframes tspinPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            40% { transform: translate(-50%, -50%) scale(1.3) rotate(-5deg); opacity: 1; }
            60% { transform: translate(-50%, -50%) scale(1.3) rotate(5deg); opacity: 1; }
            80% { transform: translate(-50%, -50%) scale(1.3) rotate(-5deg); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="gameOverScreen">
        <h1 id="gameOverTitle">挑戰失敗！</h1>
        <p id="gameOverSub" style="margin-bottom: 30px; font-size: 18px;">方塊已經觸頂了，請重新選擇模式</p>
        <div style="display: flex; gap: 15px;">
            <button onclick="startGame('TIME')">重新選擇：2分鐘模式</button>
            <button onclick="startGame('LINES')">重新選擇：40行模式</button>
        </div>
    </div>

    <div class="panel">
        <div class="btn-group">
            <button onclick="startGame('TIME')">2分鐘計分模式</button>
            <button onclick="startGame('LINES')">40行競速模式</button>
        </div>
        
        <div class="info-box preview-box">
            HOLD (Shift)
            <canvas id="holdCanvas" class="mini-canvas" width="120" height="120"></canvas>
        </div>
        
        <div class="info-box">TIME<span id="timeDisplay">0:00</span></div>
        <div class="info-box">SCORE<span id="scoreDisplay">0</span></div>
        <div class="info-box">LINES<span id="linesDisplay">0</span></div>
    </div>
    
    <div class="board-container">
        <canvas id="tetris" width="350" height="700"></canvas>
        <div id="messageDisplay"></div>
    </div>
    
    <div class="panel">
        <div class="info-box preview-box" style="flex-grow: 1;">
            NEXT
            <canvas id="nextCanvas" class="mini-canvas" width="120" height="420"></canvas>
        </div>
        
        <div class="controls-hint">
            <b>操作說明：</b><br>
            ← → : 左右移動<br>
            ↑ : 順時針旋轉<br>
            Z : 逆時針旋轉<br>
            Shift : 儲存 (Hold)<br>
            ↓ (按住) : 加速下落<br>
            空白 : 瞬間下落<br>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');
    const BLOCK_SIZE = 35; 
    context.scale(BLOCK_SIZE, BLOCK_SIZE);

    const holdCanvas = document.getElementById('holdCanvas');
    const holdCtx = holdCanvas.getContext('2d');
    const MINI_SCALE = 24; 
    holdCtx.scale(MINI_SCALE, MINI_SCALE);

    const nextCanvas = document.getElementById('nextCanvas');
    const nextCtx = nextCanvas.getContext('2d');
    nextCtx.scale(MINI_SCALE, MINI_SCALE);

    const DAS = 130; 
    const ARR = 25;  
    const keysState = { left: false, right: false };
    let leftTimer = 0;
    let rightTimer = 0;
    
    const NORMAL_DROP_SPEED = 1000;
    const FAST_DROP_SPEED = 30; 
    
    const LOCK_DELAY = 500; 
    let lockTimer = 0; 
    let dropCounter = 0;
    let dropInterval = NORMAL_DROP_SPEED;

    let lastTime = 0;
    let animationId = null;
    let gameMode = null; 
    let timer = 0;
    let timerInterval = null;
    let isGameOver = false;
    let lastActionWasRotation = false;

    let isAnimating = false;
    let clearAnimTimer = 0;
    const CLEAR_ANIM_DURATION = 120; 
    let clearLinesList = [];
    let tSpinClear = false;

    let nextQueue = [];
    let heldPieceType = null;
    let canHold = true;

    const player = { pos: {x: 0, y: 0}, matrix: null, pieceType: null, score: 0, lines: 0 };

    const pieces = 'ILJOTSZ';
    // 顏色對調：5 (S) 變為綠色 #33cc33，7 (Z) 變為紅色 #ff3333
    const colors = [
        null, '#00ffff', '#3366ff', '#ff9900', '#ffcc00', '#33cc33', '#cc33cc', '#ff3333'
    ];

    function createMatrix(w, h) {
        const matrix = [];
        while (h--) matrix.push(new Array(w).fill(0));
        return matrix;
    }

    function createPiece(type) {
        switch(type) {
            case 'I': return [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]];
            case 'J': return [[2,0,0], [2,2,2], [0,0,0]]; 
            case 'L': return [[0,0,3], [3,3,3], [0,0,0]]; 
            case 'O': return [[4,4], [4,4]];
            case 'S': return [[0,5,5], [5,5,0], [0,0,0]]; // 現在對應顏色 5: 綠色
            case 'T': return [[0,6,0], [6,6,6], [0,0,0]]; 
            case 'Z': return [[7,7,0], [0,7,7], [0,0,0]]; // 現在對應顏色 7: 紅色
        }
    }

    function fillQueue() {
        while (nextQueue.length <= 4) {
            let b = pieces.split('');
            for (let i = b.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [b[i], b[j]] = [b[j], b[i]];
            }
            nextQueue.push(...b);
        }
    }

    function drawBlock(ctx, x, y, value, isGhost = false) {
        if (value === 0) return;
        ctx.fillStyle = colors[value];
        if (isGhost) {
            ctx.globalAlpha = 0.25;
            ctx.fillRect(x, y, 1, 1);
            ctx.globalAlpha = 1;
            ctx.strokeStyle = colors[value];
            ctx.lineWidth = 0.05;
            ctx.strokeRect(x + 0.05, y + 0.05, 0.9, 0.9);
        } else {
            ctx.fillRect(x, y, 1, 1);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(x, y); ctx.lineTo(x + 1, y); ctx.lineTo(x + 0.8, y + 0.2); ctx.lineTo(x + 0.2, y + 0.2); ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x, y); ctx.lineTo(x, y + 1); ctx.lineTo(x + 0.2, y + 0.8); ctx.lineTo(x + 0.2, y + 0.2); ctx.fill();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.moveTo(x + 1, y); ctx.lineTo(x + 1, y + 1); ctx.lineTo(x + 0.8, y + 0.8); ctx.lineTo(x + 0.8, y + 0.2); ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x, y + 1); ctx.lineTo(x + 1, y + 1); ctx.lineTo(x + 0.8, y + 0.8); ctx.lineTo(x + 0.2, y + 0.8); ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 0.05;
            ctx.strokeRect(x, y, 1, 1);
        }
    }

    function drawGrid(ctx, width, height) {
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 0.02;
        for (let i = 0; i <= width; i++) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, height); ctx.stroke(); }
        for (let i = 0; i <= height; i++) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(width, i); ctx.stroke(); }
    }

    function drawMatrix(ctx, matrix, offset, isGhost = false) {
        matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) drawBlock(ctx, x + offset.x, y + offset.y, value, isGhost);
            });
        });
    }

    function drawGhost() {
        if (isAnimating) return;
        const ghost = { matrix: player.matrix, pos: { x: player.pos.x, y: player.pos.y } };
        while (!collide(arena, ghost)) { ghost.pos.y++; }
        ghost.pos.y--;
        drawMatrix(context, ghost.matrix, ghost.pos, true);
    }

    function drawHold() {
        holdCtx.clearRect(0, 0, holdCanvas.width, holdCanvas.height);
        if (heldPieceType) {
            const matrix = createPiece(heldPieceType);
            const offsetX = (5 - matrix[0].length) / 2;
            const offsetY = (5 - matrix.length) / 2;
            drawMatrix(holdCtx, matrix, {x: offsetX, y: offsetY});
        }
    }

    function drawNext() {
        nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
        for (let i = 0; i < 4; i++) {
            const type = nextQueue[i];
            if (!type) continue;
            const matrix = createPiece(type);
            const offsetX = (5 - matrix[0].length) / 2;
            const offsetY = i * 4 + 1; 
            drawMatrix(nextCtx, matrix, {x: offsetX, y: offsetY});
        }
    }

    function draw() {
        context.fillStyle = '#050505';
        context.fillRect(0, 0, canvas.width, canvas.height);
        drawGrid(context, 10, 20);
        
        drawMatrix(context, arena, {x: 0, y: 0});
        if (!isAnimating && player.matrix) {
            drawGhost(); 
            drawMatrix(context, player.matrix, player.pos); 
        }
    }

    function collide(arena, player) {
        const [m, o] = [player.matrix, player.pos];
        for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < m[y].length; ++x) {
                if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
            }
        }
        return false;
    }

    function holdPiece() {
        if (!canHold || isAnimating) return;
        if (heldPieceType === null) {
            heldPieceType = player.pieceType;
            playerReset(); 
        } else {
            const temp = player.pieceType;
            player.pieceType = heldPieceType;
            player.matrix = createPiece(heldPieceType);
            heldPieceType = temp;
            player.pos.y = 0;
            player.pos.x = Math.floor(arena[0].length / 2) - Math.floor(player.matrix[0].length / 2);
        }
        canHold = false;
        lastActionWasRotation = false;
        lockTimer = 0; 
        drawHold();
    }

    function merge(arena, player) {
        player.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value;
            });
        });
    }

    function rotate(matrix, dir) {
        for (let y = 0; y < matrix.length; ++y) {
            for (let x = 0; x < y; ++x) {
                [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
            }
        }
        if (dir > 0) matrix.forEach(row => row.reverse());
        else matrix.reverse();
    }

    function playerRotate(dir) {
        if (isAnimating) return;
        const pos = player.pos.x;
        let offset = 1;
        rotate(player.matrix, dir);
        while (collide(arena, player)) {
            player.pos.x += offset;
            offset = -(offset + (offset > 0 ? 1 : -1));
            if (offset > player.matrix[0].length) {
                rotate(player.matrix, -dir); 
                player.pos.x = pos;
                return;
            }
        }
        lastActionWasRotation = true;
        lockTimer = 0; 
    }

    function playerMove(dir) {
        if (isAnimating) return;
        player.pos.x += dir;
        if (collide(arena, player)) {
            player.pos.x -= dir;
        } else {
            lastActionWasRotation = false;
            lockTimer = 0; 
        }
    }

    function playerHardDrop() {
        if (isAnimating) return;
        while (!collide(arena, player)) { player.pos.y++; }
        player.pos.y--;
        merge(arena, player);
        if (!checkAndStartClearAnimation()) playerReset();
        
        dropCounter = 0;
        lockTimer = 0;
        keysState.left = false;
        keysState.right = false;
    }

    function isTSpin() {
        if (!lastActionWasRotation || player.pieceType !== 'T') return false;
        let corners = 0;
        const x = player.pos.x;
        const y = player.pos.y;
        if (arena[y]?.[x] !== 0) corners++;
        if (arena[y]?.[x+2] !== 0) corners++;
        if (arena[y+2]?.[x] !== 0) corners++;
        if (arena[y+2]?.[x+2] !== 0) corners++;
        return corners >= 3;
    }

    function checkAndStartClearAnimation() {
        clearLinesList = [];
        tSpinClear = isTSpin();

        for (let y = arena.length - 1; y >= 0; --y) {
            let isFull = true;
            for (let x = 0; x < arena[y].length; ++x) {
                if (arena[y][x] === 0) { isFull = false; break; }
            }
            if (isFull) clearLinesList.push(y);
        }

        if (clearLinesList.length > 0) {
            isAnimating = true;
            clearAnimTimer = CLEAR_ANIM_DURATION;
            return true; 
        }

        if (tSpinClear && lastActionWasRotation) {
             showMessage("T-SPIN!", true);
             player.score += 100;
             updateDisplay();
        }
        return false;
    }

    function executeClearLines() {
        let rowCount = clearLinesList.length;

        let newArena = [];
        for (let y = 0; y < arena.length; ++y) {
            if (!clearLinesList.includes(y)) newArena.push(arena[y]);
        }
        for (let i = 0; i < rowCount; i++) {
            newArena.unshift(new Array(10).fill(0));
        }
        arena = newArena;

        player.lines += rowCount;
        let msg = "";
        
        if (tSpinClear) {
            if (rowCount === 1) { player.score += 800; msg = "T-SPIN SINGLE"; }
            if (rowCount === 2) { player.score += 1200; msg = "T-SPIN DOUBLE"; }
            if (rowCount === 3) { player.score += 1600; msg = "T-SPIN TRIPLE"; }
        } else {
            if (rowCount === 2) { player.score += 300; msg = "DOUBLE"; }
            else if (rowCount === 3) { player.score += 500; msg = "TRIPLE"; }
            else if (rowCount === 4) { player.score += 800; msg = "TETRIS!"; }
        }
        
        if (msg !== "") showMessage(msg, tSpinClear);
        updateDisplay();
        
        if (gameMode === 'LINES' && player.lines >= 40) {
            endGame("挑戰成功！", `耗時: ${document.getElementById('timeDisplay').innerText}`);
            return;
        }

        isAnimating = false;
        playerReset();
    }

    function playerReset() {
        fillQueue(); 
        player.pieceType = nextQueue.shift(); 
        player.matrix = createPiece(player.pieceType);
        player.pos.y = 0;
        player.pos.x = Math.floor(arena[0].length / 2) - Math.floor(player.matrix[0].length / 2);
        
        lastActionWasRotation = false;
        canHold = true;
        lockTimer = 0;
        dropCounter = 0;
        
        drawNext(); 

        if (collide(arena, player)) endGame("挑戰失敗！", "方塊已經觸頂了，請重新選擇模式");
    }

    function handleContinuousInput(deltaTime) {
        if (isAnimating) return;
        if (keysState.left) {
            leftTimer += deltaTime;
            if (leftTimer >= DAS) { playerMove(-1); leftTimer -= ARR; }
        }
        if (keysState.right) {
            rightTimer += deltaTime;
            if (rightTimer >= DAS) { playerMove(1); rightTimer -= ARR; }
        }
    }

    function update(time = 0) {
        if (isGameOver) return;
        const deltaTime = time - lastTime;
        lastTime = time;

        if (isAnimating) {
            clearAnimTimer -= deltaTime;
            draw(); 
            const progress = 1 - (Math.max(0, clearAnimTimer) / CLEAR_ANIM_DURATION);
            
            if (tSpinClear) {
                context.fillStyle = `rgba(255, 215, 0, ${1 - progress})`;
                clearLinesList.forEach(y => { context.fillRect(0, y + (0.5 * progress), 10, 1 - progress); });
                context.fillStyle = `rgba(204, 51, 204, ${(1 - progress) * 0.4})`;
                context.fillRect(0, 0, 10, 20);
            } else {
                context.fillStyle = `rgba(255, 255, 255, ${1 - progress})`;
                clearLinesList.forEach(y => { context.fillRect(5 * progress, y, 10 * (1 - progress), 1); });
            }

            if (clearAnimTimer <= 0) executeClearLines();
            animationId = requestAnimationFrame(update);
            return; 
        }
        
        handleContinuousInput(deltaTime);

        player.pos.y++;
        const isTouchingGround = collide(arena, player);
        player.pos.y--;

        if (isTouchingGround) {
            lockTimer += deltaTime;
            if (lockTimer >= LOCK_DELAY) {
                merge(arena, player);
                if (!checkAndStartClearAnimation()) playerReset();
            }
        } else {
            lockTimer = 0;
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                player.pos.y++;
                dropCounter = 0;
                lastActionWasRotation = false; 
            }
        }
        
        draw();
        animationId = requestAnimationFrame(update);
    }

    function updateTimer() {
        if (isGameOver) return;
        if (gameMode === 'TIME') {
            timer--;
            if (timer <= 0) endGame("時間到！", `總分: ${player.score}`);
        } else if (gameMode === 'LINES') {
            timer++;
        }
        const m = Math.floor(Math.abs(timer) / 60);
        const s = Math.abs(timer) % 60;
        document.getElementById('timeDisplay').innerText = `${m}:${s.toString().padStart(2, '0')}`;
    }

    function updateDisplay() {
        document.getElementById('scoreDisplay').innerText = player.score;
        document.getElementById('linesDisplay').innerText = player.lines;
    }

    function showMessage(text, isTspinMsg = false) {
        const msgDiv = document.getElementById('messageDisplay');
        msgDiv.innerText = text;
        msgDiv.className = "";
        void msgDiv.offsetWidth; 
        msgDiv.className = isTspinMsg ? "msg-show msg-tspin" : "msg-show";
        setTimeout(() => { if(msgDiv.innerText === text) msgDiv.className = ""; }, 1200);
    }

    function startGame(mode) {
        document.getElementById('gameOverScreen').style.display = 'none';
        
        gameMode = mode;
        arena = createMatrix(10, 20);
        player.score = 0;
        player.lines = 0;
        isGameOver = false;
        isAnimating = false;
        nextQueue = [];
        keysState.left = false;
        keysState.right = false;
        lockTimer = 0;
        
        heldPieceType = null;
        drawHold();

        playerReset();
        updateDisplay();
        
        if (mode === 'TIME') timer = 120;
        else timer = 0;
        
        clearInterval(timerInterval);
        timerInterval = setInterval(updateTimer, 1000);
        document.getElementById('timeDisplay').innerText = mode === 'TIME' ? "2:00" : "0:00";
        
        lastTime = performance.now();
        cancelAnimationFrame(animationId);
        update(performance.now());
    }

    function endGame(titleText, subText) {
        isGameOver = true;
        clearInterval(timerInterval);
        document.getElementById('gameOverTitle').innerText = titleText;
        document.getElementById('gameOverSub').innerText = subText;
        document.getElementById('gameOverScreen').style.display = 'flex';
    }

    document.addEventListener('keydown', event => {
        if (isGameOver || !gameMode || isAnimating) return;
        if(["Space", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].indexOf(event.code) > -1) {
            event.preventDefault(); 
        }

        if (event.code === 'ArrowLeft') {
            if (!keysState.left) { playerMove(-1); keysState.left = true; leftTimer = 0; }
        }
        else if (event.code === 'ArrowRight') {
            if (!keysState.right) { playerMove(1); keysState.right = true; rightTimer = 0; }
        }
        else if (event.code === 'ArrowDown') dropInterval = FAST_DROP_SPEED;
        else if (event.code === 'ArrowUp') playerRotate(1);
        else if (event.key.toLowerCase() === 'z') playerRotate(-1);
        else if (event.key === 'Shift') holdPiece();
        else if (event.code === 'Space') playerHardDrop();
    });

    document.addEventListener('keyup', event => {
        if (event.code === 'ArrowLeft') keysState.left = false;
        else if (event.code === 'ArrowRight') keysState.right = false;
        else if (event.code === 'ArrowDown') dropInterval = NORMAL_DROP_SPEED;
    });

</script>
</body>
</html>